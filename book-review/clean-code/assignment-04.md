# 클린 코드(Clean Code)

`#노개북` `#노마드코더` `#개발자북클럽`

- 작가 : 로버트 C. 마틴
- 출판사 : 인사이트
- 읽은 기간 : 2024.01.27 ~

<br>

## Assignment #04

`2024.01.29 ~ 2024.01.30`

### 🔖 3. 함수

#### 기억하고 싶은 내용

[ 의도를 분명히 표현하는 함수를 만드는 방법 ]

1. 작게 만들기
   - 길이가 짧을수록 좋다.
2. 한 가지 일만 잘하기
   - 함수가 한 가지 일만 하는지 판단하는 방법은 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.
3. 한 함수내의 추상화 수준을 동일하게 만들기
   - 코드는 위에서 아래로 이야기처럼 읽혀야 한다.
   - 위에서 아래로 읽을 때 추상화 수준이 한 번에 한 단계씩 낮아지면 읽기 쉬워진다.
4. switch 문을 추상 팩토리에 숨기기
   - 각 case 조건에 대한 구현을 캡슐화하고, 이를 추상 팩토리를 사용하여 동적으로 선택할 수 있도록 한다.
5. 함수명은 서술적으로
   - 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
6. 이상적인 함수 매개변수의 개수는 2개 이하! [[참고]](https://github.com/qkraudghgh/clean-code-javascript-ko?tab=readme-ov-file#%ED%95%A8%EC%88%98-%EC%9D%B8%EC%9E%90%EB%8A%94-2%EA%B0%9C-%EC%9D%B4%ED%95%98%EA%B0%80-%EC%9D%B4%EC%83%81%EC%A0%81%EC%9E%85%EB%8B%88%EB%8B%A4)
   - 매개변수로 플래그를 사용하지 말자.
     - 플래그를 사용하는 것 자체가 그 함수가 한가지 이상의 역할을 하고 있다는 뜻이다.
     - boolean 기반으로 함수가 실행되는 코드가 나뉜다면 함수를 분리하자.
   - 매개변수가 2~3개 필요하다면 클래스 변수로 선언해 개념을 묶는다.
     ```java
     Circle makeCircle(double x, double y, double radius);
     Circle makeCircle(Pointer center, double radius);
     ```
   - 함수와 인수가 동사-명사 쌍을 이루면 이해하기 쉽다.
     - write(name) ➡️ writeField(name)
   - 함수 이름에 매개변수 이름을 넣으면 매개변수 순서를 기억하지 않아도 돼서 좋다.
     - assertEquals(expected, actual) ➡️ assertExpectedEqualsActual(expected, actual)
7. 사이드 이펙트 조심하기 [[참고1]](https://github.com/qkraudghgh/clean-code-javascript-ko?tab=readme-ov-file#%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8%EB%A5%BC-%ED%94%BC%ED%95%98%EC%84%B8%EC%9A%94-part-1) [[참고2]](https://github.com/qkraudghgh/clean-code-javascript-ko?tab=readme-ov-file#%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8%EB%A5%BC-%ED%94%BC%ED%95%98%EC%84%B8%EC%9A%94-part-2)
   - 예측 가능하고, 외부 상태에 의존하지 않도록 하기 위해 다음을 조심하자.
     - 함수로 넘어온 매개변수를 수정하지 않는다.
     - 함수 내부에서 전역 변수를 수정하지 않는다.
   - 특정 상황에서만 호출하게 되지 않도록 한 가지 일만 수행하도록 한다.
     - 예를 들어 checkPassword()라는 함수가 있다면 사용자의 비밀번호만 확인하고 true, false를 반환한다. 이 외에 세션을 초기화하는 로직 등이 포함된다면, 이름만 보고 호출했을 때 의도지 않은 일이 발생할 여지가 있다.
8. 명령과 조회를 분리하기
   - 함수는 상태를 변경하거나 정보를 반환하거나 둘 중 하나만 해야 한다.
9. 오류 코드보다 예외를 사용하기
   - 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리될 수 있다.
   - try/catch 블록은 정상 동작과 오류 처리 동작을 뒤섞는다. 따라서 별도의 함수로 뽑아내면 가독성이 올라간다.
     ```java
     public void delete(Page page) {
       try {
         deletePageAndAllReferences(page);
       }
       catch (Exception e) {
         logError(e);
       }
     }
     ```
   - 오류 처리도 한 가지 작업만 해야 한다.
   - 오류 코드를 사용한다는 것은 어딘가에 오류 코드를 정의해놨다는 뜻이다. 결국 오류 코드에 대한 의존성이 생긴다.

#### 오늘 읽은 소감

- 매개변수를 어디까지 넘겨줘야 하는지 항상 고민이었는데, 매개변수에 대한 이야기가 많은 도움이 됐다.
  - 최대한 2개 이하로 지정하는 것이 좋으며 그 이상이 된다면 클래스 변수(+ JS에서는 비구조화 구문)를 사용하면 좋다는 것을 알게 되었다.
  - boolean 타입을 매개변수로 사용하지 않는 게 좋다는 것을 새롭게 알게 되었다.
- 오류 코드보다 예외를 사용하라는 조언도 도움이 됐다.
  - 특히 try/catch 블록은 '원래 추하다'라는 표현이 충격적으로 와닿았다.😱
  - 정상 동작과 오류 처리 동작이 뒤섞이지 않게 해야한다는 점을 알게 되었다.
- 정상 동작과 오류 처리 동작이 뒤섞이지 않게 해야한다는 점을 알게 되었다.
- 이번 장을 읽다보니 가독성을 헤치면서 분리되어 있지 않은 뚱뚱한 함수도 좋지 않겠지만, 그렇다고 해서 기준도 없이 마구잡이로 함수를 분리해버리지 않도록 주의를 기울여야겠다는 생각을 했다. 어쨌든 중요한 것은 '이야기처럼 읽히는 코드, 한 가지 일을 잘 해내는 함수'를 만드는 것이기 때문이다.

#### 궁금한 내용 & 잘 이해되지 않는 내용

- SRP(Single Responsibility Principle)
  - _"한 가지 이유로만 변경되어야 한다."_
    - 클래스나 모듈은 단 하나의 변경 이유만을 가져야 한다. 즉, 클래스가 변경되어야 하는 이유는 딱 하나여야 한다.
    - 책임은 '왜 변경되는가'에 따라 구분되어야 하며, 변경되는 이유가 여러 개라면 클래스가 여러 개의 책임을 가지고 있다고 판단된다.
- OCP(Open-Closed Principle)
  - _"소프트웨어의 확장에는 열려 있고, 수정에는 폐쇄적이어야 한다."_
    - 새로운 기능이나 동작을 추가할 때에는 기존 코드를 변경하지 않고 확장할 수 있어야 한다. 모듈이나 클래스는 새로운 요구사항이나 기능이 추가될 때에 대응하여 확장 가능해야 한다.
    - OCP는 주로 다형성을 활용하여 달성된다. 즉, 인터페이스와 추상화를 통해 새로운 기능을 추가하거나 변경할 수 있도록 설계되어야 한다.
- 추상 팩토리
  - 객체 생성에 관련된 인터페이스를 이용하여 여러 종류의 연관된 객체를 생성할 수 있도록 하는 디자인 패턴. 구체적인 클래스의 인스턴스를 생성하는 것이 아니라, 관련된 여러 종류의 객체들을 생성하기 위한 인터페이스를 만드는 것이다.
  - 언제 사용하는가?
    - 여러 종류의 연관된 객체를 생성해야 할 때
    - 객체의 생성과 조립이 서로 관련되어 있을 때
  - 구성 요소
    - AbstractFactory(추상 팩토리): 객체 생성에 관련된 인터페이스를 정의한다. 일반적으로는 여러 종류의 "생성 메서드"를 제공한다.
    - ConcreteFactory(구체적인 팩토리): AbstractFactory를 구현한 클래스. 특정한 종류의 객체를 생성하는 책임이 있다.
    - AbstractProduct(추상 제품): 생성되는 객체들에 대한 인터페이스를 정의한다. 여러 종류의 제품에 대한 공통의 인터페이스를 제공한다.
    - ConcreteProduct(구체적인 제품): AbstractProduct를 구현한 클래스. 구체적인 객체의 생성과 구현을 담당한다.
    - Client(클라이언트): 추상 팩토리를 이용하여 객체를 생성하고 사용하는 클라이언트 코드. 클라이언트는 구체적인 팩토리와 제품 클래스를 몰라도 된다.
- AOP(Aspect Oriented Programming)
  - 코드의 횡단 관심사(cross-cutting concerns)를 모듈화하고 분리하기 위한 프로그래밍 패러다임 중 하나.
  - 횡단 관심사는 여러 모듈이나 클래스에 영향을 미치는 공통적인 부분(e.g. 로깅, 보안, 트랜잭션 관리 등)을 말한다.
  - Spring에서는 AOP, AspectJ 등의 AOP 프레임워크가 있고, NestJS에서는 Interceptor, Custom Decorator 등이 있다.
  - 클린 코드 책에서는 중복을 없애기 위한 방법 중 하나로 언급되었다!
- COP(Component Oriented Programming)
  - 소프트웨어를 구성하는 주요 단위를 "컴포넌트"로 보고, 이러한 컴포넌트들을 조립하여 전체 소프트웨어를 구축하는 프로그래밍 패러다.
  - 각각의 컴포넌트는 재사용 가능하고 독립적으로 개발될 수 있는 단위이다.
