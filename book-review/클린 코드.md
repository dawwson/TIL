# 클린 코드(Clean Code)

`#노개북` `#노마드코더` `#개발자북클럽`

- 작가 : 로버트 C. 마틴
- 출판사 : 인사이트
- 읽은 기간 : 2024.01.27 ~

<br>

## Assignment #01

`2024.01.26`

### 📔 책 구매 인증

- 가볍게 들고 다니려고 ebook으로 구매했다.
- 3주 동안 열심히 달려서 완독해보자! 🏃🏻‍♀️💨

| <img width="500px" src="https://github.com/dawwson/TIL/assets/45624238/1e6af231-cd57-42d9-a964-d84cfc28639c"> | <img width="500px" src="https://github.com/dawwson/TIL/assets/45624238/602b4be8-7ef9-4b53-a8df-9dfe1b618c2f"> |
| ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |

## Assignment #02

`2024.01.27`

### 🔖 추천사 ~ 1. 깨끗한 코드

#### 기억하고 싶은 내용

- 개발하면서 난관에 부딪힐 때 필요한 것은 **"장인 정신"**

  1. 원칙, 패턴, 기법, 경험이라는 지식을 습득한다.
  2. 열심히 일하고 연습해 몸과 마음으로 체득한다.

- 나쁜 코드로 치르는 대가

  - 나쁜 코드가 쌓일수록 팀의 생산성은 떨어진다.
    - 나쁜 코드는 프로젝트 초반에는 빠르게 진도를 나가다가 점차 느려진다.
    - 생산성이 떨어지면 관리자는 새 인력을 투입하고, 새 인력과 팀은 생산성을 높여야 한다는 압박에 더욱 시달린다.
    - 결과적으로 나쁜 코드를 더 많이 양산한다.
  - 전문가 답지 못한 태도다.
    - 관리자가 일정에 쫓기게 만들고 고객과 마케팅 부서가 무리한 요구사항을 내놓았다고 해도, 결국 프로젝트 실패는 전문가답지 못한 프로그래머의 책임이 크다.
    - 그들에게 그들의 책임이 있듯이, 프로그래머에게는 좋은 코드를 사수할 책임이 있다.
    - 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가답지 못하다.
  - 빨리 가는 유일한 방법은, **언제나 코드를 최대한 깨끗하게 유지하는 습관**이다.

- 깨끗한 코드
  - 세세한 사항까지 꼼꼼하게 처리하는 코드(오류 처리)
  - 한 가지 일에 집중하는 코드
  - 반드시 필요한 내용만 담은 코드
  - 다른 사람이 고치기 쉬운 코드
  - 주의 깊게 작성하고, 시간을 들여 깔끔하고 단정하게 정리한 코드
  - 읽으면서 짐작한 대로 돌아가는 코드

#### 오늘 읽은 소감

- 나쁜 코드로 치르는 대가로 소개된 현실적인 이야기들이 공감되었다. 내가 깨끗한 코드를 유지하지 못했던 이유를 다른 곳에서만 찾고 있지는 않았는지 반성하게 되었다.
- 깨끗한 코드를 작성해야 하는 이유를 다시 한 번 생각해보게 되었다. 결국은 내가 선택한 직무의 전문가가 되기 위함이다. 주어진 상황이 어떠하든 전문적인 프로그래머로서 져야 하는 책임들이 있고, 그 중 하나가 깨끗한 코드가 무엇인지 알고 실제로 이행하는 것임을 알게 되었다.
- 옮긴이와 저자가 이야기 하듯이, 이 책의 모든 내용이 절대적이라고 생각하지 말고 오랜 시간 뛰어난 개발자들이 고민한 기술과 기법을 이해하는 것에 집중해야겠다는 생각이 들었다.

#### 궁금한 내용 & 잘 이해되지 않는 내용

- [르블랑의 법칙 > 나중은 결코 오지 않는다. **_"Later equals Never."_**](https://on-agile.blogspot.com/2007/04/why-you-wont-fix-it-later.html)
  - 우리는 "나중에" 하려고 계획한 일을 전혀 하지 않는 경향이 있다.
    - '나중에 버그를 고치겠습니다.'
    - '나중에 단위 테스트를 작성하겠습니다.'
    - '나중에 중복을 제거하겠습니다.'
  - 왜 그럴까?
    1. 고객에게 절차를 생략해야 더 빨리 안정적으로 제품을 납품할 수 있다는 잘못된 인식을 주게 된다. 고객은 더 많은 일을 요구하게 될 것이고, 업무에 과부하가 걸리면 기술 부채가 쌓인다.
    2. 테스트와 리팩토링에 적절한 시간을 할애하지 못하게 되고, 결과적으로 디버깅과 버그 수정에 더 많은 시간을 들이게 된다.
  - 나중에 처리하기로 계획한 것들이 실제로 완료하기 위해서는, "완료 기준"을 수립해야 한다.
    - 완료의 기준에는 여러 가지가 있겠지만, 처음에는 작게 시작하고 몇 번 반복해보면서 기준을 추가해나가면 된다.
    - 처음에는 기능 완료, 단위 테스트, 동료 검토, 리팩토링 정도면 좋다.
    - 이렇게 하다 보면 "나중에" 해야할 일이 점차 줄어들어 기술 부채를 예방할 수 있다.

## Assignment #03

`2024.01.28`

### 🔖 2. 의미 있는 이름

#### 기억하고 싶은 내용

[ 이름을 잘 지을 수 있는 방법 ]

1. 의도를 분명하게 밝히기

   - 변수, 함수, 클래스 이름으로 존재 이유, 수행 기능, 사용 방법을 드러낼 수 있어야 한다.
   - 따로 주석이 필요하다면 의도가 분명하게 드러나지 않은 것이다.
   - 코드 맥락이 코드 자체에 명시적으로 드러나야 한다.

     ```java
     // Bad
     int d;  // 경과 시간(단위: 날짜)

     // Good
     int daysSinceCreation;
     int daysSinceMotdification;
     ```

2. 코드 의미를 흐리는 잘못된 정보를 남기지 않기
   - 널리 쓰이는 의미 있는 단어를 다른 의미로 사용하면 안 된다.
   - 컨테이너 유형을 이름에 넣지 않는 것이 좋다.
     - accountList ➡️ accounts
3. 의미 있게 구분하기
   - 검색 가능한 이름을 사용하자.
   - 연속된 숫자를 덧붙이는 것은 피하자.
   - 불용어를 피하자. 대체로 의미를 불분명하게 만든다.
     - 관사(a, an, the)
     - xxxInfo, xxxData, xxxObject
     - 변수 이름에 variable, 표 이름에 table
4. 발음하기 쉬운 이름 사용하기
   - 발음하기 어려우면 업무적으로 토론하기도 어렵다.
   - 프로그래밍은 사회활동이기 때문에 발음하기 쉬워야 한다.
5. 접두어 피하기
   - 멤버 변수에 'm\_'을 붙이거나, 인터페이스에 'I'을 붙이지 말자.
   - 접두어는 주의를 흐트리고, 과도한 정보를 제공한다. (차라리 구현체 이름에 접미어 Imp를 붙여라.)
6. 클래스와 객체 이름은 명사(구)
7. 메서드 이름은 동사(구)
   - 접근자/변경자/조건자는 get/set/is를 붙인다.
8. 기발한 이름은 피하기
   - 재미난 이름보다 명료한 이름이 좋다.
   - 특정 문화에서만 사용하는 농담도 피하는 것이 좋다.
9. 한 개념에 한 단어 사용하기
   - 메서드 이름은 독자적이고, 일관적이어야 한다.
     - fetch, retrieve, get ➡️ 어떤 걸 쓸 것인가?
10. 한 단어를 두 가지 목적으로 사용하지 않기
    - add, append, insert ➡️ 맥락에 따라 구분해서 쓰는 것이 좋다.
11. 기술 개념 & 도메인 영역을 구분하기
    - 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮다.
    - 도메인과 관련이 깊다면 도메인 영역에서 이름을 가져온다.

#### 오늘 읽은 소감

- 이번 장을 읽으면서, **이름을 통해 적절한 정보를 제공하여 의미와 의도를 분명히 하는 것**이 핵심이라는 것을 알게 되었다.
- 팀의 컨벤션을 맞추거나 코드 리뷰를 할 때, 막연하게 어떻게 하면 좋을 것 같다는 생각은 있었으나 왜 그렇게 생각하는지 근거를 함께 말하기가 어려웠었다. 머릿속에 어지럽게 돌아다녔던 개념들이 어느 정도 정리가 된 것 같다. 결론은 **의미를 분명하게 만드는 것!**
- 내가 실제로 사용했던 방식들이 안 좋은 케이스로 소개되어서 깜짝 놀랐다(특히 2번, 3번, 5번!!). 시간을 내서 그동안 작성했던 코드들을 다시 살펴보고 리팩토링 해봐야겠다.

#### 궁금한 내용 & 잘 이해되지 않는 내용

- ❌

## Assignment #04

`2024.01.29 ~ 2024.01.30`

### 🔖 3. 함수

#### 기억하고 싶은 내용

[ 의도를 분명히 표현하는 함수를 만드는 방법 ]

1. 작게 만들기
   - 길이가 짧을수록 좋다.
2. 한 가지 일만 잘하기
   - 함수가 한 가지 일만 하는지 판단하는 방법은 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.
3. 한 함수내의 추상화 수준을 동일하게 만들기
   - 코드는 위에서 아래로 이야기처럼 읽혀야 한다.
   - 위에서 아래로 읽을 때 추상화 수준이 한 번에 한 단계씩 낮아지면 읽기 쉬워진다.
4. switch 문을 추상 팩토리에 숨기기
   - 각 case 조건에 대한 구현을 캡슐화하고, 이를 추상 팩토리를 사용하여 동적으로 선택할 수 있도록 한다.
5. 함수명은 서술적으로
   - 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
6. 이상적인 함수 매개변수의 개수는 2개 이하! [[참고]](https://github.com/qkraudghgh/clean-code-javascript-ko?tab=readme-ov-file#%ED%95%A8%EC%88%98-%EC%9D%B8%EC%9E%90%EB%8A%94-2%EA%B0%9C-%EC%9D%B4%ED%95%98%EA%B0%80-%EC%9D%B4%EC%83%81%EC%A0%81%EC%9E%85%EB%8B%88%EB%8B%A4)
   - 매개변수로 플래그를 사용하지 말자.
     - 플래그를 사용하는 것 자체가 그 함수가 한가지 이상의 역할을 하고 있다는 뜻이다.
     - boolean 기반으로 함수가 실행되는 코드가 나뉜다면 함수를 분리하자.
   - 매개변수가 2~3개 필요하다면 클래스 변수로 선언해 개념을 묶는다.
     ```java
     Circle makeCircle(double x, double y, double radius);
     Circle makeCircle(Pointer center, double radius);
     ```
   - 함수와 인수가 동사-명사 쌍을 이루면 이해하기 쉽다.
     - write(name) ➡️ writeField(name)
   - 함수 이름에 매개변수 이름을 넣으면 매개변수 순서를 기억하지 않아도 돼서 좋다.
     - assertEquals(expected, actual) ➡️ assertExpectedEqualsActual(expected, actual)
7. 사이드 이펙트 조심하기 [[참고1]](https://github.com/qkraudghgh/clean-code-javascript-ko?tab=readme-ov-file#%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8%EB%A5%BC-%ED%94%BC%ED%95%98%EC%84%B8%EC%9A%94-part-1) [[참고2]](https://github.com/qkraudghgh/clean-code-javascript-ko?tab=readme-ov-file#%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8%EB%A5%BC-%ED%94%BC%ED%95%98%EC%84%B8%EC%9A%94-part-2)
   - 예측 가능하고, 외부 상태에 의존하지 않도록 하기 위해 다음을 조심하자.
     - 함수로 넘어온 매개변수를 수정하지 않는다.
     - 함수 내부에서 전역 변수를 수정하지 않는다.
   - 특정 상황에서만 호출하게 되지 않도록 한 가지 일만 수행하도록 한다.
     - 예를 들어 checkPassword()라는 함수가 있다면 사용자의 비밀번호만 확인하고 true, false를 반환한다. 이 외에 세션을 초기화하는 로직 등이 포함된다면, 이름만 보고 호출했을 때 의도지 않은 일이 발생할 여지가 있다.
8. 명령과 조회를 분리하기
   - 함수는 상태를 변경하거나 정보를 반환하거나 둘 중 하나만 해야 한다.
9. 오류 코드보다 예외를 사용하기
   - 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리될 수 있다.
   - try/catch 블록은 정상 동작과 오류 처리 동작을 뒤섞는다. 따라서 별도의 함수로 뽑아내면 가독성이 올라간다.
     ```java
     public void delete(Page page) {
       try {
         deletePageAndAllReferences(page);
       }
       catch (Exception e) {
         logError(e);
       }
     }
     ```
   - 오류 처리도 한 가지 작업만 해야 한다.
   - 오류 코드를 사용한다는 것은 어딘가에 오류 코드를 정의해놨다는 뜻이다. 결국 오류 코드에 대한 의존성이 생긴다.

#### 오늘 읽은 소감

- 매개변수를 어디까지 넘겨줘야 하는지 항상 고민이었는데, 매개변수에 대한 이야기가 많은 도움이 됐다.
  - 최대한 2개 이하로 지정하는 것이 좋으며 그 이상이 된다면 클래스 변수(+ JS에서는 비구조화 구문)를 사용하면 좋다는 것을 알게 되었다.
  - boolean 타입을 매개변수로 사용하지 않는 게 좋다는 것을 새롭게 알게 되었다.
- 오류 코드보다 예외를 사용하라는 조언도 도움이 됐다.
  - 특히 try/catch 블록은 '원래 추하다'라는 표현이 충격적으로 와닿았다.😱
  - 정상 동작과 오류 처리 동작이 뒤섞이지 않게 해야한다는 점을 알게 되었다.
- 이번 장을 읽다보니 가독성을 헤치면서 분리되어 있지 않은 뚱뚱한 함수도 좋지 않겠지만, 그렇다고 해서 기준도 없이 마구잡이로 함수를 분리해버리지 않도록 주의를 기울여야겠다는 생각을 했다. 어쨌든 중요한 것은 '이야기처럼 읽히는 코드, 한 가지 일을 잘 해내는 함수'를 만드는 것이기 때문이다.

#### 궁금한 내용 & 잘 이해되지 않는 내용

- SRP(Single Responsibility Principle)
  - _"한 가지 이유로만 변경되어야 한다."_
    - 클래스나 모듈은 단 하나의 변경 이유만을 가져야 한다. 즉, 클래스가 변경되어야 하는 이유는 딱 하나여야 한다.
    - 책임은 '왜 변경되는가'에 따라 구분되어야 하며, 변경되는 이유가 여러 개라면 클래스가 여러 개의 책임을 가지고 있다고 판단된다.
- OCP(Open-Closed Principle)
  - _"소프트웨어의 확장에는 열려 있고, 수정에는 폐쇄적이어야 한다."_
    - 새로운 기능이나 동작을 추가할 때에는 기존 코드를 변경하지 않고 확장할 수 있어야 한다. 모듈이나 클래스는 새로운 요구사항이나 기능이 추가될 때에 대응하여 확장 가능해야 한다.
    - OCP는 주로 다형성을 활용하여 달성된다. 즉, 인터페이스와 추상화를 통해 새로운 기능을 추가하거나 변경할 수 있도록 설계되어야 한다.
- 추상 팩토리
  - 객체 생성에 관련된 인터페이스를 이용하여 여러 종류의 연관된 객체를 생성할 수 있도록 하는 디자인 패턴. 구체적인 클래스의 인스턴스를 생성하는 것이 아니라, 관련된 여러 종류의 객체들을 생성하기 위한 인터페이스를 만드는 것이다.
  - 언제 사용하는가?
    - 여러 종류의 연관된 객체를 생성해야 할 때
    - 객체의 생성과 조립이 서로 관련되어 있을 때
  - 구성 요소
    - AbstractFactory(추상 팩토리): 객체 생성에 관련된 인터페이스를 정의한다. 일반적으로는 여러 종류의 "생성 메서드"를 제공한다.
    - ConcreteFactory(구체적인 팩토리): AbstractFactory를 구현한 클래스. 특정한 종류의 객체를 생성하는 책임이 있다.
    - AbstractProduct(추상 제품): 생성되는 객체들에 대한 인터페이스를 정의한다. 여러 종류의 제품에 대한 공통의 인터페이스를 제공한다.
    - ConcreteProduct(구체적인 제품): AbstractProduct를 구현한 클래스. 구체적인 객체의 생성과 구현을 담당한다.
    - Client(클라이언트): 추상 팩토리를 이용하여 객체를 생성하고 사용하는 클라이언트 코드. 클라이언트는 구체적인 팩토리와 제품 클래스를 몰라도 된다.
- AOP(Aspect Oriented Programming)
  - 코드의 횡단 관심사(cross-cutting concerns)를 모듈화하고 분리하기 위한 프로그래밍 패러다임 중 하나.
  - 횡단 관심사는 여러 모듈이나 클래스에 영향을 미치는 공통적인 부분(e.g. 로깅, 보안, 트랜잭션 관리 등)을 말한다.
  - Spring에서는 AOP, AspectJ 등의 AOP 프레임워크가 있고, NestJS에서는 Interceptor, Custom Decorator 등이 있다.
  - 클린 코드 책에서는 중복을 없애기 위한 방법 중 하나로 언급되었다!
- COP(Component Oriented Programming)
  - 소프트웨어를 구성하는 주요 단위를 "컴포넌트"로 보고, 이러한 컴포넌트들을 조립하여 전체 소프트웨어를 구축하는 프로그래밍 패러다임이다.
  - 각각의 컴포넌트는 재사용 가능하고 독립적으로 개발될 수 있는 단위이다.

## Assignment #05

`2024.01.31 ~ 2024.02.01`

### 🔖 4. 주석

#### 기억하고 싶은 내용

1. 주석은 나쁜 코드를 보완하지 못한다.
   - 코드의 의도를 명확히 표현하는 것이 우선으로 하고, 주석은 줄이려고 노력해야 한다.
   -
2. 좋은 주석이란?
   - 법적인 주석
     - 저작권, 소유권 정보
   - 정보를 제공하는 주석
     - BUT 주석 보다는 함수 이름에 정보를 담는 편이 좋다.
   - 구현 의도를 설명하는 주석
   - 모호한 인수나 반환값의 의미를 명료하게 밝히는 주석
   - 결과를 경고하는 주석
     - ~하지 마세요, ~때문에 안전하지 못하니 주의하세요 등
   - TODO 주석
     - 앞으로의 할 일, 필요하지만 당장 구현하기 어려운 업무
   - 그냥 넘어갈 수 있는 부분의 중요성을 강조하는 주석
   - 공개 API의 Javadocs
3. 나쁜 주석이란?
   - 이해가 어려운, 명료하지 않은 주석
   - 코드 내용을 그대로 설명하는 주석
   - 오해할 여지가 있는 주석
     - 코드보다 읽기 어렵고 잘못된 정보가 포함된 경우
   - 의무적으로 다는 주석
     - 공개하지 않을 코드라면 모든 함수에 Javadocs를 달 필요는 없다.
     - 모든 변수에 주석을 달 필요는 없다.
   - 변경 이력을 기록하는 주석
     - 이제는 버전 관리 시스템이 있기 때문에 완전히 지우는 게 좋다.
   - 너무나 당연해서 새로운 정보를 제공하지 못하는 주석
     - 읽는 사람이 오히려 부주의하게 넘기기 쉽다.
   - 위치를 표시하는 주석
     - `// Actions ////////////////////`
     - 반드시 필요한 경우 드물게 사용해야 한다.
     - 적절한 들여쓰기와 포맷팅, 함수와 변수에 의미를 부여하는 것으로 주석을 없앨 수 있다. [[참고]](https://github.com/qkraudghgh/clean-code-javascript-ko?tab=readme-ov-file#%EC%BD%94%EB%93%9C%EC%9D%98-%EC%9C%84%EC%B9%98%EB%A5%BC-%EC%84%A4%EB%AA%85%ED%95%98%EC%A7%80-%EB%A7%88%EC%84%B8%EC%9A%94)
   - 닫는 괄호에 다는 주석
     - 중첩이 심하고 장황한 함수가 아니라면 의미가 없다.
   - 저자를 표시하는 주석
     - 버전 관리 시스템으로 알 수 있다. 달 필요가 없다.
   - 주석 처리한 코드
     - 삭제해도 버전 관리 시스템으로 알 수 있다. 과감하게 삭제하는 게 좋다.
   - 너무 많은 정보를 담은 주석
4. 요약
   - 주석을 다는 것은 필수적인 것이 아니다. 좋은 코드는 주석보다 코드 자체로 말한다.
   - 주석이 필요하지 않도록 코드를 개선하려는 (함수, 변수, 클래스 명에 의도를 담는)노력이 필요하다.
   - 주석을 달 때는
     - 이해하기 쉽고 명료하게!
     - 코드 자체를 설명하지 않도록!
     - 구현 의도 설명, 주의할 내용, 중요성을 강조하는 부분, TODO 정도면 충분함

#### 오늘 읽은 소감

- 주석을 줄이려고 노력해야 한다는 관점이 새로웠다. 돌이켜 생각해보니 오픈소스 또는 코드를 잘 작성한 동료 개발자의 코드를 봤을 때 주석이 거의 없었다. 그럼에도 불구하고 코드의 흐름을 잘 따라갈 수 있었던 기억이 있다.
- 좋은 주석이란 무엇인지에 대한 기준이 생긴 것 같다. 코드를 작성할 때와 마찬가지로 주석도 잘 읽혀지는 게 중요하다는 생각이 들었다.

#### 궁금한 내용 & 잘 이해되지 않는 내용

- ❌

## Assignment #07

`2024.02.03`

### 🔖 5. 형식 맞추기

#### 기억하고 싶은 내용

[ 왜 형식을 맞춰야 할까? ]

- 코드 형식은 의사소통의 일환이다.
- 코드는 바뀔지라도 처음 잡아놓은 구현 스타일과 가독성 수준은 사라지지 않는다.
- 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다.

<br>

[ 소통을 원활하게 하는 코드 형식 1 : 세로 형식 맞추기 ]

1. 적절한 세로 길이
   - 큰 규모의 프로젝트도 파일당 200줄 미만으로 작성한 사례들이 있다.
   - 엄격하게 지킬 필요는 없지만, 큰 파일보다는 작은 파일이 읽기 쉽다.
2. 빈 행으로 분리하기
   - 패키지 선언부, 함수와 함수 사이 등 적절하게 빈 행을 넣어서 가독성을 높이자.
3. 서로 밀접한 코드는 가까이 놓기 ➡️ `개념적 유사성`
   - 하나의 파일 안에 위치한다.
   - 변수는 사용하는 위치에 최대한 가깝운 곳에 선언한다.
   - 인스턴스 변수는 클래스 맨 처음이든 마지막이든 한 곳으로 모은다.
   - 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치시킨다.
     - 가능하다면 호출하는 함수를 호출되는 함수보다 위에 위치시킨다. `고차원 ➡️ 저차원`
     - 호출하는 함수 바로 아래에 호출되는 순서대로 배치하면 더 좋다.

<br>

[ 소통을 원활하게 하는 코드 형식 2 : 가로 형식 맞추기 ]

1. 한 행의 길이를 짧게 유지하자
   - 120자 이내로 권장한다.
2. 적절한 공백
   - 할당문 공백  
     `const value = 1`
   - 함수 파라미터 공백  
     `function f1(a, b) { }`
   - 수식에서 연산자 우선순위에 따른 공백  
     `return b*b - 4*a*c;`
3. 적절한 정렬과 들여쓰기

   - 간단한 if 문이라도 들여쓰기를 권장한다.

     ```js
     // Bad
     if (a) return true;

     // Good
     if (a) {
       return true;
     }
     ```

#### 오늘 읽은 소감

- [JavaScript Standard Style](https://standardjs.com/rules.html) 이라는 것을 발견했다... vscode prettier 익스텐션 깔아놓으면 자동 정렬돼서 별로 신경을 안 쓰고 있었는데, 틈틈히 읽어서 린팅 규칙을 커스텀 해봐야겠다.
- 개발자마다 각자의 취향이 있다보니 팀 규칙을 정하는 게 어려웠었는데 책의 내용을 많이 참고할 수 있을 것 같다.

#### 궁금한 내용 & 잘 이해되지 않는 내용

- `p.103`
  - C++ 가위 규칙(scissors-rule)
    - 모든 인스턴스 변수를 클래스 마지막에 선언한다.
- `p.105`

  - 저차원 함수에서 상수를 사용할 때, 상수를 알아야 마땅한 함수에서 실제로 사용하는 함수로 상수로 넘겨주는 방법이 더 좋다.

    1. 고차원 함수 : 더 추상화된 레벨의 함수. 주로 비즈니스 로직이나 높은 수준의 기능을 다룬다.
    2. 저차원 함수 : 구체적이고 상세한 구현을 담당하는 함수. 주로 세부적인 기능을 처리한다.
    3. 고차원 함수에서 저차원 함수로 상수를 전달함으로써, 고차원 함수가 세부적인 로직을 신경 쓰지 않고 저차원 함수에게 특정한 작업을 위임할 수 있다.

  - 예시

    ```js
    // 고차원 함수
    function calculateTotalPrice(price, quantity) {
    const taxRate = 0.1; // 세율 상수

        // 저차원 함수 호출
        const totalPrice = calculatePriceWithTax(price, quantity, taxRate);

        console.log(`Total Price: $${totalPrice}`);

    }

    // 저차원 함수
    function calculatePriceWithTax(price, quantity, taxRate) {
    // 세금을 고려한 총 가격 계산
      const totalPrice = price _ quantity _ (1 + taxRate);
      return totalPrice;
    }

    // 고차원 함수 호출
    calculateTotalPrice(20, 3);
    ```
