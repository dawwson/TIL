# 다이나믹 프로그래밍

## 정의

- 다이나믹 프로그래밍(dynamic programming)은 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘이다.

## 특징

다이나믹 프로그래밍으로 풀 수 있는 문제들은 다음과 같은 특징을 가진다.

**1. 최적 부분 구조(optimal substructure)**

- 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우를 말한다.

- 최적 부분 구조를 풀이하는 또 다른 방법으로 그리디(greedy) 알고리즘이 있다.
  - 그리디 알고리즘은 항상 그 순간에 최적이라고 생각되는 것을 선택하면서 푸는 것이고, 다이나믹 프로그래밍은 중복된 하위 문제들의 결과를 저장해뒀다가 풀이해나간다는 차이가 있다.

**2. 중복된 하위 문제들(overlapping subproblems)**

- 작은 부분 문제들을 여러 번 해결해야 하는 경우를 말한다.

- 중복되지 않는 문제들은 다이나믹 프로그래밍으로 풀지 않는다.

  - e.g. 병합 정렬, 퀵 정렬은 분할 정복 알고리즘으로 분류한다.

<br>

## 다이나믹 프로그래밍 방법론

### 1. 상향식 접근법(bottom-up)

- 작은 부분 문제부터 시작하여, 작은 문제의 결과를 이용하여 점차적으로 큰 문제를 해결해나가는 방식이다.

- 데이터를 테이블 형태로 만들면서 문제를 풀이한다고 하여 타뷸레이션(tabulation)이라고도 부르며, 일반적으로 이 방식만을 다이나믹 프로그래밍으로 지칭하기도 한다.

#### 풀이 단계

[ 예시 : 피보나치 수열 ]

```js
function fib(n) {
  const dp = [0, 1];

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}
```

1. 부분 문제 정의

   - 문제 해결 과정을 작은 부분 문제들로 나누어 정의한다.

2. 기저 사례 정의

   - 가장 작은 크기의 부분 문제에 대한 결과를 미리 정의하여 상태(state) 배열을 초기화한다.

3. 반복문 구성 및 점화식 작성

   - 작은 문제에서 시작하여 큰 문제에 도달할 때까지 반복한다.

   - 이전 부분 문제의 해결 결과를 이용하여 점화식을 작성한다.

   - 반복문을 실행하여 중간 결과를 상태 배열에 저장한다.

4. 결과 반환
   - 상태 배열에 저장된 최종 결과를 반환한다.

<br>

### 2. 하향식 접근법(top-down)

- 큰 문제를 작은 부분 문제로 나누어 해결하는 방식이다.

- 큰 문제를 해결하기 위해 작은 부분 문제들을 재귀적으로 호출하여 해결한다.

- 이미 풀어봤는지 확인하여 재활용하는 방식으로, 메모이제이션(memoization)이라고도 부른다.

#### 풀이 단계

[ 예시 : 피보나치 수열 ]

```js
const dp = [];

function fib(n) {
  if (n <= 1) {
    return n;
  }

  if (dp[n]) {
    return dp[n];
  }

  dp[n] = fib(n - 1) + fib(n - 2);
  return dp[n];
}
```

1. 기저 사례 정의

   - 재귀 함수가 호출될 때, 가장 작은 크기의 부분 문제에 대한 결과를 미리 정의한다.

   - 재귀 호출을 종료하는 조건으로 사용된다.

2. 메모이제이션

   - 이전에 계산한 값을 저장할 배열이나 해시 테이블을 생성한다.

   - 재귀 함수가 호출될 때마다 계산한 결과를 저장하고, 이후에 동일한 입력에 대해 저장된 결과를 사용한다.

3. 재귀 함수 및 점화식 작성

   - 큰 문제를 작은 문제로 분할하는 재귀 함수를 작성한다.

   - 재귀 함수에서 이전 부분 문제의 해결 결과를 이용하여 점화식을 작성한다.

4. 재귀 함수 호출 및 결과 반환

<br>

## 소스 코드(JS)

### 1. 파스칼 삼각형

- 상향식 접근법을 사용하여 파스칼의 삼각형을 생성하는 문제이다.

- 주어진 numRows만큼의 행을 생성하면서, 각 행을 생성할 때 이전 행의 값을 활용하여 현재 행을 계산한다.

  ```js
  /**
   * @param {number} numRows
   * @return {number[][]}
   */
  var generate = function (numRows) {
    const result = [];

    for (let i = 0; i < numRows; i++) {
      const row = new Array(i + 1).fill(1);

      for (let j = 1; j < i; j++) {
        row[j] = result[i - 1][j - 1] + result[i - 1][j];
      }
      result.push(row);
    }
    return result;
  };
  ```

<br>

### 2. 1의 개수 세기

- 상향식 접근법을 사용하여 0부터 n까지의 각 숫자에 대해 이진 표현에서 1의 개수를 계산하는 문제이다.

- 이전 숫자의 비트 수를 활용하여 현재 숫자의 비트 수를 계산한다.

  ```js
  /**
   * @param {number} n
   * @return {number[]}
   */
  var countBits = function (n) {
    const result = [0];

    for (let i = 1; i <= n; i++) {
      result[i] = result[i >> 1] + (i & 1);
    }

    return result;
  };
  ```

<br>

## 참고

> 1. 도서
>    - 파이썬 알고리즘 인터뷰 - 박상길
> 2. 관련 알고리즘 문제 풀이
>    - [리트코드 118번 Pascal's Triangle](https://github.com/dawwson/algorithm/blob/main/leetcode/easy/118.%20Pascal's%20Triangle.md)
>    - [리트코드 338번 Counting Bits](https://github.com/dawwson/algorithm/blob/main/leetcode/easy/338.%20Counting%20Bits.md)
